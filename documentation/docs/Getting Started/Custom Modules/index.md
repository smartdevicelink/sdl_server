The policy server relies on custom modules to do work that the policy server cannot do because otherwise the server will make some unnecessary assumptions that may not make sense for some developers. Splitting up work into separate modules and allowing customization of those modules is what makes the policy server so flexible. There are some basic restrictions and functions required to implement for custom modules to work, and that will be covered here.

The policy server previously used custom modules for collecting data from the database and building the policy table. This is now handled by SQL statements generated by the policy server. The initial data inserted into the database at the time of migration comes from statements generated by scripts in the `/scripts` folder. The user will not need to run these manually in order to start up their policy server.

## Loggers
Only two named functions need to be exported in an object for a valid implementation: `info` and `error`. `info` accepts a string as its first parameter and is used to log non-error messages using the string. `error` accepts a string and is used for logging error messages using the string. Check the default `winston` module for an example.

## Databases
Only slightly more complicated than the logger, the export should be just a function with a logger object as the argument. This object is the same object as the one exported in the custom logger module, so `info` and `error` can be invoked on it. In addition to exporting a function, it must return an object with a function in it named `sqlCommand`:
```
return {
    sqlCommand: function (query, callback) {
    }
}
```

`query` is the SQL string to execute, and `callback` is the function to invoke when `sqlCommand` is complete. Check out the default `postgres` module for an example implementation.
